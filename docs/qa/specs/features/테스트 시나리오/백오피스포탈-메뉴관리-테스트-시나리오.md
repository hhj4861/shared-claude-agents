# 백오피스포탈 메뉴 관리 시스템 QA 테스트 시나리오

## 문서 정보

| 항목 | 내용 |
|------|------|
| 작성일 | 2026-01-08 |
| 버전 | 1.0 |
| 작성자 | QA Scenario Writer |
| 대상 시스템 | 백오피스포탈 메뉴 관리 시스템 |
| Base URL (Dev) | https://backoffice-gateway.socar.me |
| Base URL (Prod) | https://backoffice-gateway.socarcorp.co.kr |

## 우선순위 정의

| 우선순위 | 설명 | 커버리지 목표 |
|---------|------|--------------|
| P0 Critical | 핵심 비즈니스 로직, 인증/인가, 데이터 무결성 | 100% |
| P1 High | 주요 기능, 에러 처리, 권한 검증 | 90%+ |
| P2 Medium | 부가 기능, 엣지 케이스, 성능 | 70%+ |
| P3 Low | UI/UX, 문서화, 예외 상황 | 50%+ |

---

# 1. 클라이언트 관리 테스트 시나리오

## 1.1 클라이언트 생성 (POST /api/v1/backoffice-clients)

### TC-CLI-001: 클라이언트 정상 생성 [P0]
```yaml
시나리오: 유효한 정보로 새 백오피스 클라이언트를 생성한다
사전조건:
  - 관리자 권한 JWT 토큰 보유
  - 동일한 clientId가 존재하지 않음
테스트_데이터:
  request_body:
    clientId: "test-backoffice-001"
    clientName: "테스트 백오피스"
    description: "테스트용 백오피스 시스템"
기대결과:
  status_code: 200
  response:
    success: true
  검증항목:
    - DB에 클라이언트 레코드 생성 확인
    - Keycloak에 Client 등록 확인
    - menu_group 테이블에 기본 메뉴 그룹 생성 확인
    - 기본 Scope (GET, POST, PUT, DELETE, PATCH) 생성 확인
```

### TC-CLI-002: 중복 clientId로 생성 시도 [P1]
```yaml
시나리오: 이미 존재하는 clientId로 클라이언트 생성을 시도한다
사전조건:
  - "existing-client" clientId가 이미 존재함
테스트_데이터:
  request_body:
    clientId: "existing-client"
    clientName: "중복 테스트"
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
    message: "이미 존재하는 Client ID입니다."
```

### TC-CLI-003: 필수 필드 누락 [P1]
```yaml
시나리오: clientId 없이 클라이언트 생성을 시도한다
테스트_데이터:
  request_body:
    clientName: "필드 누락 테스트"
    description: "설명만 있음"
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
```

### TC-CLI-004: clientId 유효성 검사 - 특수문자 [P2]
```yaml
시나리오: 허용되지 않은 특수문자가 포함된 clientId로 생성 시도
테스트_데이터:
  - clientId: "test@client"
  - clientId: "test client"
  - clientId: "test!#$%"
  - clientId: "<script>alert(1)</script>"
기대결과:
  status_code: 400
  검증항목:
    - XSS 공격 코드가 필터링됨
    - 영문 소문자, '-', '_'만 허용
```

### TC-CLI-005: clientId 경계값 테스트 [P2]
```yaml
시나리오: clientId 길이 경계값 테스트
테스트_데이터:
  - clientId: "" (빈 문자열)
  - clientId: "a" (최소 1자)
  - clientId: "a" * 255 (최대 길이)
  - clientId: "a" * 256 (최대 길이 초과)
기대결과:
  빈_문자열: 400 BAD_REQUEST
  최소_길이: 200 OK
  최대_길이: 200 OK
  초과_길이: 400 BAD_REQUEST
```

---

## 1.2 클라이언트 목록 조회 (GET /api/v1/backoffice-clients)

### TC-CLI-006: 클라이언트 목록 전체 조회 [P0]
```yaml
시나리오: 등록된 모든 백오피스 클라이언트 목록을 조회한다
사전조건:
  - 최소 2개 이상의 클라이언트 등록됨
기대결과:
  status_code: 200
  response:
    success: true
    data:
      clients: array (length >= 2)
  검증항목:
    - 각 클라이언트에 id, clientId, clientName, description, createdAt, updatedAt 포함
```

### TC-CLI-007: 페이징 조회 [P1]
```yaml
시나리오: 페이지네이션을 적용하여 클라이언트 목록을 조회한다
테스트_데이터:
  query_params:
    page: 1
    size: 10
기대결과:
  status_code: 200
  검증항목:
    - 반환된 클라이언트 수 <= size
    - 페이지 정보가 정확함
```

### TC-CLI-008: 검색 조건 적용 [P2]
```yaml
시나리오: 검색 조건을 적용하여 클라이언트 목록을 조회한다
테스트_데이터:
  query_params:
    condition: { clientName: "백오피스" }
기대결과:
  status_code: 200
  검증항목:
    - 반환된 클라이언트 이름에 "백오피스" 포함
```

---

## 1.3 클라이언트 상세 조회 (GET /api/v1/backoffice-clients/{clientId})

### TC-CLI-009: 존재하는 클라이언트 상세 조회 [P0]
```yaml
시나리오: 존재하는 클라이언트의 상세 정보를 조회한다
사전조건:
  - clientId=2인 클라이언트 존재
테스트_데이터:
  path_params:
    clientId: 2
기대결과:
  status_code: 200
  response:
    success: true
    data:
      id: 2
      clientId: string
      clientName: string
      description: string
```

### TC-CLI-010: 존재하지 않는 클라이언트 조회 [P1]
```yaml
시나리오: 존재하지 않는 clientId로 상세 조회를 시도한다
테스트_데이터:
  path_params:
    clientId: 99999
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
    message: "Client를 찾을 수 없습니다."
```

### TC-CLI-011: 유효하지 않은 clientId 형식 [P2]
```yaml
시나리오: 숫자가 아닌 clientId로 조회 시도
테스트_데이터:
  - clientId: "abc"
  - clientId: "-1"
  - clientId: "0"
기대결과:
  status_code: 400 또는 404
```

---

## 1.4 클라이언트 수정 (PUT /api/v1/backoffice-clients/{clientId})

### TC-CLI-012: 클라이언트 정보 정상 수정 [P0]
```yaml
시나리오: 기존 클라이언트의 이름과 설명을 수정한다
사전조건:
  - clientId=2인 클라이언트 존재
테스트_데이터:
  path_params:
    clientId: 2
  request_body:
    clientName: "수정된 백오피스"
    description: "수정된 설명"
기대결과:
  status_code: 200
  response:
    success: true
  검증항목:
    - DB에서 clientName, description 업데이트 확인
    - updatedAt 필드 갱신 확인
```

### TC-CLI-013: 존재하지 않는 클라이언트 수정 [P1]
```yaml
시나리오: 존재하지 않는 clientId로 수정을 시도한다
테스트_데이터:
  path_params:
    clientId: 99999
  request_body:
    clientName: "수정 시도"
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
```

### TC-CLI-014: 빈 문자열로 수정 시도 [P2]
```yaml
시나리오: clientName을 빈 문자열로 수정 시도
테스트_데이터:
  request_body:
    clientName: ""
    description: "빈 이름 테스트"
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
```

---

## 1.5 권한 있는 클라이언트 목록 조회 V2 (GET /api/v2/clients/authorized)

### TC-CLI-015: JWT 기반 권한 있는 클라이언트 조회 [P0]
```yaml
시나리오: JWT 토큰의 resource_access에서 롤을 가진 클라이언트만 조회한다
사전조건:
  - JWT 토큰에 phoenix-test1, partner-center 클라이언트 롤 포함
  - activityYn=true인 클라이언트만 반환
테스트_데이터:
  headers:
    Authorization: "Bearer {valid_jwt_token}"
  query_params:
    includeMenus: false
기대결과:
  status_code: 200
  response:
    success: true
    data:
      clients: array
  검증항목:
    - 롤이 있는 클라이언트만 반환됨
    - socar-backoffice-portal 클라이언트 제외됨
    - 각 클라이언트에 id, name, keycloakClientId, type, url 포함
```

### TC-CLI-016: 메뉴 포함하여 권한 있는 클라이언트 조회 [P0]
```yaml
시나리오: includeMenus=true로 권한 있는 클라이언트와 메뉴를 함께 조회한다
테스트_데이터:
  headers:
    Authorization: "Bearer {valid_jwt_token}"
  query_params:
    includeMenus: true
기대결과:
  status_code: 200
  검증항목:
    - 각 클라이언트에 menus 배열 포함
    - menus에 id, parentId, name, type, url, displayOrder, scopes 포함
    - 권한 있는 메뉴만 포함됨
```

### TC-CLI-017: 권한 없는 JWT 토큰으로 조회 [P1]
```yaml
시나리오: 어떤 클라이언트에도 롤이 없는 JWT 토큰으로 조회
사전조건:
  - JWT 토큰의 resource_access가 비어있음
기대결과:
  status_code: 200
  response:
    data:
      clients: [] (빈 배열)
```

### TC-CLI-018: 만료된 JWT 토큰으로 조회 [P1]
```yaml
시나리오: 만료된 JWT 토큰으로 권한 있는 클라이언트 조회
테스트_데이터:
  headers:
    Authorization: "Bearer {expired_jwt_token}"
기대결과:
  status_code: 401
  error:
    status: "UNAUTHORIZED"
```

### TC-CLI-019: JWT 토큰 없이 조회 [P1]
```yaml
시나리오: Authorization 헤더 없이 권한 있는 클라이언트 조회
테스트_데이터:
  headers: {} (Authorization 없음)
기대결과:
  status_code: 401
  error:
    status: "UNAUTHORIZED"
```

---

# 2. 메뉴 관리 테스트 시나리오

## 2.1 메뉴 목록 조회 (GET /api/v2/menus)

### TC-MENU-001: flat 포맷으로 메뉴 목록 조회 [P0]
```yaml
시나리오: flat 포맷으로 특정 클라이언트의 메뉴 목록을 조회한다
사전조건:
  - phoenix2 클라이언트에 메뉴가 등록되어 있음
테스트_데이터:
  query_params:
    keycloakClientId: "phoenix2"
    format: "flat"
기대결과:
  status_code: 200
  response:
    success: true
    data:
      menus: array
  검증항목:
    - 각 메뉴에 id, parentId, name, type, url, displayOrder 포함
    - displayYn, privacyIncludeYn, locationIncludeYn 포함
    - 계층 구조 없이 flat하게 반환
```

### TC-MENU-002: tree 포맷으로 메뉴 목록 조회 [P0]
```yaml
시나리오: tree 포맷으로 특정 클라이언트의 메뉴 목록을 조회한다
테스트_데이터:
  query_params:
    keycloakClientId: "phoenix2"
    format: "tree"
기대결과:
  status_code: 200
  response:
    data:
      keycloakClientId: "phoenix2"
      clientName: string
      menus: array
  검증항목:
    - 최상위 메뉴의 parentId가 null
    - GROUP 타입 메뉴에 children 배열 포함
    - 계층 구조가 올바르게 구성됨 (최대 2 Depth)
```

### TC-MENU-003: 존재하지 않는 클라이언트 메뉴 조회 [P1]
```yaml
시나리오: 존재하지 않는 keycloakClientId로 메뉴 조회
테스트_데이터:
  query_params:
    keycloakClientId: "non-existent-client"
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
    message: "Client를 찾을 수 없습니다."
```

### TC-MENU-004: 유효하지 않은 format 파라미터 [P2]
```yaml
시나리오: 유효하지 않은 format 값으로 메뉴 조회
테스트_데이터:
  query_params:
    keycloakClientId: "phoenix2"
    format: "invalid"
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
```

### TC-MENU-005: keycloakClientId 누락 [P1]
```yaml
시나리오: keycloakClientId 파라미터 없이 메뉴 조회
테스트_데이터:
  query_params: {}
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
    message: "유효하지 않은 Client ID입니다."
```

### TC-MENU-006: 메뉴 관리 권한 없는 사용자 조회 시도 [P1]
```yaml
시나리오: 메뉴 관리 권한이 없는 사용자가 메뉴 조회 시도
사전조건:
  - JWT 토큰에 메뉴 관리 권한 없음
기대결과:
  status_code: 403
  error:
    status: "FORBIDDEN"
    message: "해당 작업을 수행할 권한이 없습니다."
```

---

## 2.2 메뉴 상세 조회 (GET /api/v2/menus/{menuId})

### TC-MENU-007: 메뉴 상세 정상 조회 [P0]
```yaml
시나리오: 존재하는 메뉴의 상세 정보를 조회한다
사전조건:
  - menuId=11인 메뉴 존재
테스트_데이터:
  path_params:
    menuId: 11
기대결과:
  status_code: 200
  response:
    success: true
    data:
      id: 11
      parentId: number or null
      name: string
      type: "GROUP" or "ITEM"
      url: string or null
      displayOrder: number
      displayYn: boolean
      privacyIncludeYn: boolean
      locationIncludeYn: boolean
      resources: array
```

### TC-MENU-008: 메뉴 상세 조회 - 리소스 매핑 정보 포함 [P0]
```yaml
시나리오: ITEM 타입 메뉴의 리소스 매핑 정보를 함께 조회한다
사전조건:
  - menuId=11이 ITEM 타입이고 리소스가 매핑되어 있음
기대결과:
  검증항목:
    - resources 배열에 resourceId, resourceName, displayName, scopes 포함
    - scopes에 GET, POST, PUT, DELETE 등 HTTP 메서드 포함
```

### TC-MENU-009: 존재하지 않는 메뉴 조회 [P1]
```yaml
시나리오: 존재하지 않는 menuId로 상세 조회
테스트_데이터:
  path_params:
    menuId: 99999
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
    message: "메뉴를 찾을 수 없습니다."
```

### TC-MENU-010: 음수 menuId로 조회 [P2]
```yaml
시나리오: 음수 menuId로 메뉴 상세 조회
테스트_데이터:
  path_params:
    menuId: -1
기대결과:
  status_code: 400 또는 404
```

---

## 2.3 메뉴 일괄 Upsert (PUT /api/v2/menus)

### TC-MENU-011: 신규 메뉴 생성 (id 없음) [P0]
```yaml
시나리오: id 없이 새로운 메뉴를 생성한다
테스트_데이터:
  query_params:
    keycloakClientId: "phoenix2"
  request_body:
    menus:
      - parentId: null
        name: "신규 메뉴 그룹"
        type: "GROUP"
        displayOrder: 99
        displayYn: true
    deleteIds: []
기대결과:
  status_code: 200
  response:
    success: true
    data:
      created: 1
      results:
        - action: "created"
  검증항목:
    - DB에 새 메뉴 레코드 생성됨
    - 자동 생성된 id 반환
```

### TC-MENU-012: 기존 메뉴 수정 (id 있음) [P0]
```yaml
시나리오: 기존 메뉴의 이름과 순서를 수정한다
테스트_데이터:
  query_params:
    keycloakClientId: "phoenix2"
  request_body:
    menus:
      - id: 10
        parentId: null
        name: "수정된 메뉴명"
        type: "GROUP"
        displayOrder: 1
        displayYn: true
기대결과:
  status_code: 200
  response:
    data:
      updated: 1
      results:
        - id: 10
          action: "updated"
```

### TC-MENU-013: 메뉴 삭제 (deleteIds 사용) [P0]
```yaml
시나리오: deleteIds를 사용하여 메뉴를 삭제한다
테스트_데이터:
  query_params:
    keycloakClientId: "phoenix2"
  request_body:
    menus: []
    deleteIds: [15, 16]
기대결과:
  status_code: 200
  response:
    data:
      deleted: 2
      results:
        - id: 15
          action: "deleted"
        - id: 16
          action: "deleted"
  검증항목:
    - DB에서 해당 메뉴 삭제됨
    - 메뉴-리소스 매핑도 함께 삭제됨
```

### TC-MENU-014: 생성, 수정, 삭제 복합 작업 [P1]
```yaml
시나리오: 한 번의 요청으로 생성, 수정, 삭제를 동시에 수행한다
테스트_데이터:
  request_body:
    menus:
      - id: 10
        name: "수정될 메뉴"
        type: "GROUP"
        displayOrder: 1
      - parentId: 10
        name: "새로 생성될 메뉴"
        type: "ITEM"
        url: "/new-page"
        displayOrder: 5
    deleteIds: [20]
기대결과:
  status_code: 200
  response:
    data:
      created: 1
      updated: 1
      deleted: 1
```

### TC-MENU-015: ITEM 타입에 url 누락 [P1]
```yaml
시나리오: ITEM 타입 메뉴 생성 시 url을 누락한다
테스트_데이터:
  request_body:
    menus:
      - parentId: 10
        name: "URL 누락 테스트"
        type: "ITEM"
        displayOrder: 1
        # url 누락
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
    details:
      - field: "menus[0].url"
        message: "ITEM 타입은 url이 필수입니다."
```

### TC-MENU-016: displayOrder 중복 [P2]
```yaml
시나리오: 동일 레벨에서 displayOrder가 중복되는 메뉴 생성
테스트_데이터:
  request_body:
    menus:
      - id: 10
        parentId: null
        displayOrder: 1
      - parentId: null
        name: "중복 순서"
        displayOrder: 1
기대결과:
  status_code: 400
  error:
    message: "displayOrder: 동일 레벨에서 중복 불가"
```

### TC-MENU-017: 3 Depth 이상 메뉴 생성 시도 [P1]
```yaml
시나리오: 최대 2 Depth를 초과하는 메뉴 생성 시도
사전조건:
  - parentId=11인 메뉴가 이미 2 Depth (GROUP > ITEM)
테스트_데이터:
  request_body:
    menus:
      - parentId: 11  # 이미 2 depth인 메뉴
        name: "3 Depth 시도"
        type: "ITEM"
        url: "/too-deep"
        displayOrder: 1
기대결과:
  status_code: 400
  error:
    message: "최대 2 Depth까지만 생성 가능합니다."
```

### TC-MENU-018: 메뉴명 XSS 공격 [P0 - 보안]
```yaml
시나리오: 메뉴명에 XSS 공격 코드 삽입 시도
테스트_데이터:
  request_body:
    menus:
      - name: "<script>alert('XSS')</script>"
        type: "GROUP"
        displayOrder: 1
기대결과:
  옵션1:
    status_code: 400
    error: "유효하지 않은 문자가 포함되어 있습니다."
  옵션2:
    status_code: 200
    검증항목:
      - 저장된 값이 이스케이프 처리됨
      - HTML 태그가 제거되거나 인코딩됨
```

### TC-MENU-019: SQL Injection 공격 [P0 - 보안]
```yaml
시나리오: 메뉴명에 SQL Injection 공격 시도
테스트_데이터:
  request_body:
    menus:
      - name: "'; DROP TABLE menus;--"
        type: "GROUP"
        displayOrder: 1
기대결과:
  검증항목:
    - SQL Injection이 실행되지 않음
    - DB 테이블이 정상 상태
    - 적절한 에러 또는 이스케이프 처리
```

### TC-MENU-020: 권한 없는 사용자의 Upsert 시도 [P0]
```yaml
시나리오: 메뉴 관리 권한 없는 사용자가 메뉴 Upsert 시도
사전조건:
  - JWT 토큰에 메뉴 관리 권한 없음
기대결과:
  status_code: 403
  error:
    status: "FORBIDDEN"
    message: "메뉴 관리 권한이 없습니다."
```

---

## 2.4 메뉴 삭제 (DELETE /api/v2/menus/{menuId})

### TC-MENU-021: 하위 메뉴 없는 메뉴 삭제 [P0]
```yaml
시나리오: 하위 메뉴가 없는 ITEM 메뉴를 삭제한다
사전조건:
  - menuId=12가 하위 메뉴 없는 ITEM
테스트_데이터:
  path_params:
    menuId: 12
  query_params:
    cascade: false
기대결과:
  status_code: 200
  response:
    success: true
    data:
      deletedId: 12
      deletedChildren: []
```

### TC-MENU-022: 하위 메뉴 있는 메뉴 삭제 - cascade=false [P1]
```yaml
시나리오: 하위 메뉴가 있는 GROUP 메뉴를 cascade=false로 삭제 시도
사전조건:
  - menuId=10에 하위 메뉴 3개 존재
테스트_데이터:
  path_params:
    menuId: 10
  query_params:
    cascade: false
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
    message: "하위 메뉴가 존재합니다. cascade=true로 요청하거나 하위 메뉴를 먼저 삭제하세요."
    details:
      childrenCount: 3
```

### TC-MENU-023: 하위 메뉴 있는 메뉴 삭제 - cascade=true [P0]
```yaml
시나리오: 하위 메뉴가 있는 GROUP 메뉴를 cascade=true로 삭제
테스트_데이터:
  path_params:
    menuId: 10
  query_params:
    cascade: true
기대결과:
  status_code: 200
  response:
    data:
      deletedId: 10
      deletedChildren: [11, 12, 13]
  검증항목:
    - 상위 메뉴와 모든 하위 메뉴 삭제됨
    - 관련 메뉴-리소스 매핑도 삭제됨
```

### TC-MENU-024: 존재하지 않는 메뉴 삭제 [P1]
```yaml
시나리오: 존재하지 않는 menuId로 삭제 시도
테스트_데이터:
  path_params:
    menuId: 99999
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
    message: "메뉴를 찾을 수 없습니다."
```

### TC-MENU-025: 삭제 권한 없는 사용자 [P1]
```yaml
시나리오: 메뉴 삭제 권한 없는 사용자가 삭제 시도
기대결과:
  status_code: 403
  error:
    status: "FORBIDDEN"
    message: "메뉴 삭제 권한이 없습니다."
```

---

## 2.5 메뉴 리소스 매핑 (GET/PUT /api/v2/menus/{menuId}/resources)

### TC-MENU-026: 메뉴 리소스 조회 [P0]
```yaml
시나리오: 특정 메뉴에 연결된 리소스 목록을 조회한다
테스트_데이터:
  path_params:
    menuId: 11
기대결과:
  status_code: 200
  response:
    success: true
    data:
      menuId: 11
      resources: array
  검증항목:
    - 각 리소스에 id, resourceId, resourceName, displayName, scopes 포함
```

### TC-MENU-027: 메뉴 리소스 수정 - 리소스 추가 [P0]
```yaml
시나리오: 메뉴에 새로운 리소스를 매핑한다
테스트_데이터:
  path_params:
    menuId: 11
  query_params:
    keycloakClientId: "phoenix2"
  request_body:
    resources:
      - resourceId: "f7a4c8d3-9b2e-4f1a-8c7d-3e5f9a2b1c0d"
      - resourceId: "a1b2c3d4-5e6f-7890-abcd-ef1234567890"
기대결과:
  status_code: 200
  response:
    success: true
  검증항목:
    - 메뉴-리소스 매핑 테이블에 레코드 생성
```

### TC-MENU-028: 리소스 매핑 시 개인정보 플래그 자동 업데이트 [P0]
```yaml
시나리오: personalInfoHandleYn=true인 리소스 매핑 시 메뉴 플래그 업데이트
사전조건:
  - resourceId가 personalInfoHandleYn=true
  - 상위 메뉴 존재 (parentId)
테스트_데이터:
  path_params:
    menuId: 11
  request_body:
    resources:
      - resourceId: "{personal_info_resource_id}"
기대결과:
  검증항목:
    - 해당 메뉴(menuId=11)의 privacyIncludeYn=true
    - 상위 메뉴의 privacyIncludeYn=true
    - 상위 메뉴의 다른 하위 메뉴에는 영향 없음
```

### TC-MENU-029: 리소스 매핑 시 위치정보 플래그 자동 업데이트 [P0]
```yaml
시나리오: locationInfoHandleYn=true인 리소스 매핑 시 메뉴 플래그 업데이트
사전조건:
  - resourceId가 locationInfoHandleYn=true
테스트_데이터:
  request_body:
    resources:
      - resourceId: "{location_info_resource_id}"
기대결과:
  검증항목:
    - 해당 메뉴의 locationIncludeYn=true
    - 상위 메뉴 체인의 locationIncludeYn=true
```

### TC-MENU-030: 리소스 제거 시 플래그 재계산 [P1]
```yaml
시나리오: 개인정보 리소스 제거 시 플래그가 재계산된다
사전조건:
  - 메뉴에 personalInfoHandleYn=true 리소스만 매핑됨
  - 현재 privacyIncludeYn=true
테스트_데이터:
  request_body:
    resources: [] (빈 배열로 모든 리소스 제거)
기대결과:
  검증항목:
    - 해당 메뉴의 privacyIncludeYn=false로 변경
    - 상위 메뉴도 다른 하위 메뉴 기준으로 재계산
```

### TC-MENU-031: 유효하지 않은 resourceId로 매핑 시도 [P1]
```yaml
시나리오: 존재하지 않는 resourceId로 리소스 매핑 시도
테스트_데이터:
  request_body:
    resources:
      - resourceId: "invalid-uuid-format"
      - resourceId: "00000000-0000-0000-0000-000000000000"
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
    message: "유효하지 않은 Resource ID가 포함되어 있습니다."
```

### TC-MENU-032: GROUP 타입 메뉴에 리소스 매핑 시도 [P2]
```yaml
시나리오: GROUP 타입 메뉴에 리소스 매핑을 시도한다
사전조건:
  - menuId=10이 GROUP 타입
테스트_데이터:
  path_params:
    menuId: 10
  request_body:
    resources:
      - resourceId: "{valid_resource_id}"
기대결과:
  옵션1:
    status_code: 400
    error: "GROUP 타입에는 리소스를 매핑할 수 없습니다."
  옵션2:
    status_code: 200
    note: "정책에 따라 허용될 수 있음"
```

---

# 3. 권한 기반 메뉴 조회 테스트 시나리오

## 3.1 사용자 권한 기반 메뉴 조회 (GET /api/v2/menus/authorized)

### TC-AUTH-001: 단일 클라이언트 권한 메뉴 조회 [P0]
```yaml
시나리오: 단일 클라이언트의 권한 있는 메뉴만 조회한다
사전조건:
  - JWT 토큰에 phoenix2 클라이언트 롤 포함
  - 해당 롤에 일부 리소스 접근 권한 있음
테스트_데이터:
  headers:
    Authorization: "Bearer {valid_jwt_token}"
  query_params:
    keycloakClientIds: "phoenix2"
기대결과:
  status_code: 200
  response:
    success: true
    data:
      - keycloakClientId: "phoenix2"
        clientName: string
        accessUrl: string
        menus: array
  검증항목:
    - 권한 있는 ITEM 메뉴만 포함
    - 하위 메뉴가 모두 권한 없으면 상위 GROUP 제외
    - scopes에 허용된 HTTP 메서드만 포함
```

### TC-AUTH-002: 다중 클라이언트 권한 메뉴 조회 [P0]
```yaml
시나리오: 여러 클라이언트의 권한 메뉴를 한 번에 조회한다
테스트_데이터:
  headers:
    Authorization: "Bearer {valid_jwt_token}"
  query_params:
    keycloakClientIds: "phoenix2,another-client"
기대결과:
  status_code: 200
  response:
    data: array (length: 2)
  검증항목:
    - 각 클라이언트별로 권한 메뉴 반환
    - 권한 없는 클라이언트는 빈 menus 배열
```

### TC-AUTH-003: scopes 권한 검증 [P0]
```yaml
시나리오: 메뉴별 scopes에 사용자 권한이 정확히 반영되는지 검증
사전조건:
  - 사용자가 user-management 리소스에 GET, POST만 권한 있음
테스트_데이터:
  headers:
    Authorization: "Bearer {limited_scope_token}"
기대결과:
  검증항목:
    - ITEM 메뉴의 scopes: ["GET", "POST"]
    - PUT, DELETE는 scopes에 미포함
    - GROUP 메뉴의 scopes: null
```

### TC-AUTH-004: 권한 변경 후 메뉴 반영 확인 [P0]
```yaml
시나리오: 사용자 권한 변경 후 메뉴 조회에 반영되는지 확인
사전조건:
  - 사용자가 특정 메뉴 접근 권한 없음
테스트_단계:
  1. 권한 없는 상태에서 메뉴 조회 -> 해당 메뉴 미노출 확인
  2. Keycloak에서 사용자에게 권한 부여
  3. 캐시 TTL(5분) 이후 또는 캐시 무효화 후 재조회
  4. 해당 메뉴 노출 확인
기대결과:
  검증항목:
    - 권한 변경이 캐시 정책에 따라 반영됨
    - 최대 5분 이내 반영 (RPT 캐시 TTL)
```

### TC-AUTH-005: JWT 토큰에서 userId 추출 실패 [P1]
```yaml
시나리오: sub claim이 없는 JWT 토큰으로 조회
테스트_데이터:
  headers:
    Authorization: "Bearer {token_without_sub}"
기대결과:
  status_code: 200
  response:
    data:
      - menus: [] (빈 배열)
  note: "정책에 따라 빈 메뉴 반환"
```

### TC-AUTH-006: 존재하지 않는 클라이언트 ID로 조회 [P1]
```yaml
시나리오: 존재하지 않는 keycloakClientId로 권한 메뉴 조회
테스트_데이터:
  query_params:
    keycloakClientIds: "non-existent-client"
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
    message: "keycloakClientId가 non-existent-client인 클라이언트가 존재하지 않습니다."
    details:
      reason: "BACKOFFICE_CLIENT_NOT_FOUND"
```

### TC-AUTH-007: 메뉴 그룹 존재하지 않을 때 [P1]
```yaml
시나리오: 클라이언트는 있지만 메뉴 그룹이 없는 경우
사전조건:
  - 클라이언트 존재하지만 menu_group 레코드 없음
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
    message: "clientId가 {id}인 메뉴 그룹이 존재하지 않습니다."
```

### TC-AUTH-008: 다중 리소스 매핑 OR 조건 검증 [P1]
```yaml
시나리오: 하나의 메뉴에 여러 리소스가 매핑되어 있을 때 OR 조건 검증
사전조건:
  - 메뉴에 resource-a, resource-b 매핑됨
  - 사용자는 resource-a만 권한 있음
기대결과:
  검증항목:
    - 해당 메뉴가 노출됨 (OR 조건)
    - scopes에는 resource-a의 권한만 포함
```

### TC-AUTH-009: displayYn=false 메뉴 제외 확인 [P2]
```yaml
시나리오: displayYn=false인 메뉴가 권한 메뉴 조회에서 제외되는지 확인
사전조건:
  - 특정 메뉴의 displayYn=false
  - 사용자는 해당 메뉴 권한 있음
기대결과:
  검증항목:
    - displayYn=false 메뉴는 결과에 미포함
```

### TC-AUTH-010: 트리 구조 정확성 검증 [P1]
```yaml
시나리오: 반환된 메뉴 트리 구조가 올바른지 검증
기대결과:
  검증항목:
    - 최상위 메뉴의 parentId=null
    - children 배열의 각 메뉴 parentId가 부모 id와 일치
    - displayOrder 순서대로 정렬됨
    - 최대 2 Depth 구조
```

---

# 4. Resource 관리 테스트 시나리오

## 4.1 Resource 목록 조회 (GET /api/v2/keycloak/resources)

### TC-RES-001: Resource 전체 목록 조회 [P0]
```yaml
시나리오: Keycloak에 등록된 모든 Resource 목록을 조회한다
기대결과:
  status_code: 200
  response:
    success: true
    data:
      resources: array
  검증항목:
    - 각 Resource에 resourceId, name, displayName, type, uris, scope 포함
    - deleteYn=true인 리소스는 제외됨
```

### TC-RES-002: 특정 클라이언트의 Resource 조회 [P0]
```yaml
시나리오: 특정 clientId의 Resource만 필터링하여 조회
테스트_데이터:
  query_params:
    clientId: "backoffice-admin"
기대결과:
  status_code: 200
  검증항목:
    - 모든 Resource가 해당 clientId에 속함
```

### TC-RES-003: 존재하지 않는 clientId로 조회 [P2]
```yaml
시나리오: 존재하지 않는 clientId로 Resource 조회
테스트_데이터:
  query_params:
    clientId: "non-existent"
기대결과:
  status_code: 200
  response:
    data:
      resources: [] (빈 배열)
```

---

## 4.2 Resource 상세 조회 (GET /api/v2/keycloak/resources/{resourceId})

### TC-RES-004: Resource 상세 조회 [P0]
```yaml
시나리오: 특정 Resource의 상세 정보를 조회한다
테스트_데이터:
  path_params:
    resourceId: "f7a4c8d3-9b2e-4f1a-8c7d-3e5f9a2b1c0d"
  query_params:
    clientId: "backoffice-admin"
기대결과:
  status_code: 200
  response:
    success: true
    data:
      resourceId: string
      name: string
      displayName: string
      type: "api-endpoint"
      uris: array
      scope: string
      roles: array
      gatewayApplyYn: boolean
      personalInfoHandleYn: boolean
      locationInfoHandleYn: boolean
      apiActivity: string
```

### TC-RES-005: 존재하지 않는 resourceId 조회 [P1]
```yaml
시나리오: 존재하지 않는 resourceId로 상세 조회
테스트_데이터:
  path_params:
    resourceId: "00000000-0000-0000-0000-000000000000"
  query_params:
    clientId: "backoffice-admin"
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
```

### TC-RES-006: clientId 파라미터 누락 [P1]
```yaml
시나리오: clientId 쿼리 파라미터 없이 상세 조회
테스트_데이터:
  path_params:
    resourceId: "{valid_resource_id}"
  query_params: {}
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
```

---

## 4.3 Resource 등록 (POST /api/v2/keycloak/resources)

### TC-RES-007: Resource 정상 등록 [P0]
```yaml
시나리오: 새로운 API Resource를 등록한다
테스트_데이터:
  request_body:
    uris: ["/api/v2/test"]
    scope: "GET"
    clientId: "backoffice-admin"
    type: "api-endpoint"
    roles: ["admin", "manager"]
    gatewayApplyYn: true
    personalInfoHandleYn: false
    locationInfoHandleYn: false
기대결과:
  status_code: 201
  response:
    success: true
    data:
      resourceId: string (UUID)
      name: "GET /api/v2/test {uuid}" (자동 생성)
      scope: "GET"
  검증항목:
    - Keycloak에 Resource 등록됨
    - name: "SCOPE URI UUID" 형식
    - displayName: "SCOPE URI" 형식
```

### TC-RES-008: Resource 등록 시 Policy/Permission 자동 생성 [P0]
```yaml
시나리오: roles 지정 시 Policy와 Permission이 자동 생성되는지 확인
테스트_데이터:
  request_body:
    uris: ["/api/v2/auto-permission"]
    scope: "POST"
    clientId: "backoffice-admin"
    roles: ["admin"]
기대결과:
  검증항목:
    - Keycloak에 {name}-policy Policy 생성됨
    - Keycloak에 {name}-permission Permission 생성됨
    - Permission이 해당 Resource와 연결됨
```

### TC-RES-009: publicAuthYn=true로 Resource 등록 [P1]
```yaml
시나리오: 공개 API Resource를 등록한다
테스트_데이터:
  request_body:
    uris: ["/api/v2/public"]
    scope: "GET"
    clientId: "backoffice-admin"
    publicAuthYn: true
기대결과:
  검증항목:
    - public-policy가 적용됨
    - 인증 없이 접근 가능한 리소스로 설정됨
```

### TC-RES-010: 필수 필드 누락 [P1]
```yaml
시나리오: 필수 필드 없이 Resource 등록 시도
테스트_케이스:
  - uris 누락
  - scope 누락
  - clientId 누락
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
```

### TC-RES-011: 유효하지 않은 scope 값 [P2]
```yaml
시나리오: 유효하지 않은 HTTP 메서드로 Resource 등록
테스트_데이터:
  request_body:
    uris: ["/api/v2/invalid"]
    scope: "INVALID_METHOD"
    clientId: "backoffice-admin"
기대결과:
  status_code: 400
  error:
    message: "scope는 GET, POST, PUT, DELETE, PATCH 중 하나여야 합니다."
```

### TC-RES-012: 중복 URI 등록 시도 [P2]
```yaml
시나리오: 이미 등록된 URI와 동일한 scope로 Resource 등록
사전조건:
  - GET /api/v2/existing이 이미 등록됨
테스트_데이터:
  request_body:
    uris: ["/api/v2/existing"]
    scope: "GET"
    clientId: "backoffice-admin"
기대결과:
  옵션1:
    status_code: 400
    error: "이미 등록된 Resource입니다."
  옵션2:
    status_code: 200
    note: "정책에 따라 업데이트될 수 있음"
```

---

## 4.4 Resource 일괄 생성 (POST /api/v2/keycloak/resources/batch)

### TC-RES-013: Resource 일괄 생성 [P0]
```yaml
시나리오: API Route 기반으로 Resource를 일괄 생성한다
테스트_데이터:
  request_body:
    clientId: "phoenix2"
    apiRouteId: 103
    contextPath: "/api"
    roles: ["admin"]
    gatewayApplyYn: true
기대결과:
  status_code: 200
  response:
    data:
      createdCount: number
      skippedCount: number
      created: array
      skipped: array
  검증항목:
    - 대상 서비스의 모든 API가 Resource로 생성됨
    - 유효하지 않은 메서드는 skipped에 포함
```

### TC-RES-014: 일괄 생성 시 중복 처리 [P1]
```yaml
시나리오: 이미 존재하는 Resource가 포함된 경우 처리
사전조건:
  - 일부 API가 이미 Resource로 등록됨
기대결과:
  검증항목:
    - 중복 Resource는 skipped에 포함
    - 신규 Resource만 created에 포함
```

---

## 4.5 Resource 수정 (PUT /api/v2/keycloak/resources/{resourceId})

### TC-RES-015: Resource 정보 수정 [P0]
```yaml
시나리오: 기존 Resource의 정보를 수정한다
테스트_데이터:
  path_params:
    resourceId: "{existing_resource_id}"
  query_params:
    clientId: "backoffice-admin"
  request_body:
    name: "user-management-v2"
    displayName: "사용자 관리 v2"
    uris: ["/api/v2/users", "/api/v2/users/*"]
    gatewayApplyYn: true
    personalInfoHandleYn: true
기대결과:
  status_code: 200
  response:
    success: true
```

### TC-RES-016: personalInfoHandleYn 변경 시 메뉴 플래그 재계산 [P0]
```yaml
시나리오: Resource의 개인정보 처리 여부 변경 시 연결된 메뉴 플래그가 재계산된다
사전조건:
  - Resource가 메뉴에 매핑되어 있음
  - 현재 personalInfoHandleYn=false
테스트_데이터:
  request_body:
    personalInfoHandleYn: true
기대결과:
  검증항목:
    - 연결된 메뉴의 privacyIncludeYn=true
    - 상위 메뉴 체인의 privacyIncludeYn=true
```

### TC-RES-017: locationInfoHandleYn 변경 시 메뉴 플래그 재계산 [P0]
```yaml
시나리오: Resource의 위치정보 처리 여부 변경 시 연결된 메뉴 플래그가 재계산된다
테스트_데이터:
  request_body:
    locationInfoHandleYn: true
기대결과:
  검증항목:
    - 연결된 메뉴의 locationIncludeYn=true
    - 상위 메뉴 체인의 locationIncludeYn=true
```

### TC-RES-018: apiRouteId 수정 불가 확인 [P2]
```yaml
시나리오: apiRouteId 필드가 수정 불가인지 확인
테스트_데이터:
  request_body:
    apiRouteId: 999
기대결과:
  검증항목:
    - apiRouteId는 변경되지 않음
    - 요청 무시 또는 에러 반환
```

---

## 4.6 Resource 삭제 (DELETE /api/v2/keycloak/resources/{resourceId})

### TC-RES-019: Resource 삭제 [P0]
```yaml
시나리오: 기존 Resource를 삭제한다
테스트_데이터:
  path_params:
    resourceId: "{existing_resource_id}"
  query_params:
    clientId: "backoffice-admin"
기대결과:
  status_code: 204
  검증항목:
    - Keycloak에서 Resource 삭제됨 (Hard Delete)
    - 연결된 Permission 삭제됨
    - 연결된 Policy 삭제됨
    - 메뉴-리소스 매핑(PortalMenuResource) 삭제됨
```

### TC-RES-020: Resource 삭제 시 메뉴 플래그 재계산 [P0]
```yaml
시나리오: 개인정보 Resource 삭제 시 연결된 메뉴의 플래그가 재계산된다
사전조건:
  - personalInfoHandleYn=true Resource가 메뉴에 유일하게 매핑됨
기대결과:
  검증항목:
    - 삭제 전 메뉴 플래그 재계산됨
    - 해당 메뉴의 privacyIncludeYn=false로 변경
```

### TC-RES-021: 존재하지 않는 Resource 삭제 [P1]
```yaml
시나리오: 존재하지 않는 resourceId로 삭제 시도
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
```

---

## 4.7 Resource 일괄 수정 (PATCH /api/v2/keycloak/resources)

### TC-RES-022: Resource 일괄 수정 [P0]
```yaml
시나리오: 여러 Resource의 속성을 한 번에 수정한다
테스트_데이터:
  request_body:
    clientId: "backoffice-admin"
    targetResourceIds:
      - "f7a4c8d3-9b2e-4f1a-8c7d-3e5f9a2b1c0d"
      - "a1b2c3d4-5e6f-7890-abcd-ef1234567890"
    gatewayApplyYn: true
    personalInfoHandleYn: false
기대결과:
  status_code: 200
  검증항목:
    - 지정된 모든 Resource의 gatewayApplyYn=true
    - null이 아닌 필드만 업데이트됨
```

### TC-RES-023: roles 일괄 수정 [P1]
```yaml
시나리오: 여러 Resource의 roles를 일괄 변경한다
테스트_데이터:
  request_body:
    clientId: "backoffice-admin"
    targetResourceIds: ["{id1}", "{id2}"]
    roles: ["admin", "manager"]
기대결과:
  검증항목:
    - 각 Resource의 Permission이 새 roles로 업데이트됨
```

### TC-RES-024: roles 빈 배열로 일괄 수정 [P1]
```yaml
시나리오: roles를 빈 배열로 설정하여 Policy를 삭제한다
테스트_데이터:
  request_body:
    clientId: "backoffice-admin"
    targetResourceIds: ["{id1}"]
    roles: []
기대결과:
  검증항목:
    - 해당 Resource의 Policy가 삭제됨
```

### TC-RES-025: deleteYn=true로 일괄 삭제 [P1]
```yaml
시나리오: deleteYn=true로 Resource를 일괄 삭제한다
테스트_데이터:
  request_body:
    clientId: "backoffice-admin"
    targetResourceIds: ["{id1}", "{id2}"]
    deleteYn: true
기대결과:
  검증항목:
    - 해당 Resource들이 완전 삭제됨
```

---

# 5. Role 관리 테스트 시나리오

## 5.1 Role 목록 조회 (GET /api/v2/keycloak/roles)

### TC-ROLE-001: Role 전체 목록 조회 [P0]
```yaml
시나리오: Keycloak에 등록된 모든 Role 목록을 조회한다
기대결과:
  status_code: 200
  response:
    success: true
    data:
      roles: array
  검증항목:
    - 각 Role에 roleId, name, displayName, description 포함
    - clientRole, clientId, permissionCount 포함
```

### TC-ROLE-002: 특정 클라이언트의 Role 조회 [P0]
```yaml
시나리오: 특정 clientId의 Role만 조회한다
테스트_데이터:
  query_params:
    clientId: "backoffice-admin"
기대결과:
  status_code: 200
  검증항목:
    - 모든 Role의 clientId가 "backoffice-admin"
```

---

## 5.2 Role 생성 (POST /api/v2/keycloak/roles)

### TC-ROLE-003: Role 정상 생성 [P0]
```yaml
시나리오: 새로운 Role을 생성한다
테스트_데이터:
  request_body:
    name: "test_viewer"
    displayName: "테스트 조회자"
    description: "테스트 조회 전용 권한"
    clientId: "backoffice-admin"
기대결과:
  status_code: 201
  response:
    success: true
    data:
      roleId: string (UUID)
      name: "test_viewer"
  검증항목:
    - Keycloak에 Role 생성됨
    - 동일 이름의 Role-based Policy 자동 생성됨
```

### TC-ROLE-004: 중복 Role 이름으로 생성 시도 [P1]
```yaml
시나리오: 이미 존재하는 Role 이름으로 생성 시도
사전조건:
  - "existing_role" 이름의 Role이 존재
테스트_데이터:
  request_body:
    name: "existing_role"
    clientId: "backoffice-admin"
기대결과:
  status_code: 400
  error:
    message: "Role 명 중복 불가"
```

### TC-ROLE-005: 예약어로 Role 생성 시도 [P1]
```yaml
시나리오: Keycloak 예약어로 Role 생성 시도
테스트_케이스:
  - name: "default-roles-backoffice-admin"
  - name: "offline_access"
  - name: "uma_authorization"
기대결과:
  status_code: 400
  error:
    message: "예약어는 Role 이름으로 사용할 수 없습니다."
```

### TC-ROLE-006: Role 이름 형식 검증 [P2]
```yaml
시나리오: 허용되지 않는 형식의 Role 이름으로 생성
테스트_케이스:
  - name: "Test Role" (공백 포함)
  - name: "test@role" (특수문자)
  - name: "TestRole" (대문자)
기대결과:
  status_code: 400
  검증항목:
    - 영문 소문자, '-', '_', 숫자만 허용
```

---

## 5.3 Role 수정 (PUT /api/v2/keycloak/roles/{roleId})

### TC-ROLE-007: Role 정보 수정 [P0]
```yaml
시나리오: 기존 Role의 displayName과 description을 수정한다
테스트_데이터:
  path_params:
    roleId: "{existing_role_id}"
  request_body:
    displayName: "수정된 역할명"
    description: "수정된 설명"
기대결과:
  status_code: 200
  response:
    data:
      roleId: string
      updated: true
      keycloakSyncSuccess: true
  검증항목:
    - Keycloak에 변경사항 동기화됨
```

### TC-ROLE-008: 존재하지 않는 Role 수정 [P1]
```yaml
시나리오: 존재하지 않는 roleId로 수정 시도
테스트_데이터:
  path_params:
    roleId: "00000000-0000-0000-0000-000000000000"
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
```

---

## 5.4 Role 삭제 (DELETE /api/v2/keycloak/roles/{roleId})

### TC-ROLE-009: Role 삭제 [P0]
```yaml
시나리오: 기존 Role을 삭제한다
테스트_데이터:
  path_params:
    roleId: "{existing_role_id}"
  query_params:
    clientId: "backoffice-admin"
기대결과:
  status_code: 204
  검증항목:
    - Keycloak에서 Role 삭제됨
    - 연결된 Policy 삭제됨
    - 해당 Role이 연결된 Permission들 업데이트됨
```

### TC-ROLE-010: 사용 중인 Role 삭제 시 영향도 [P1]
```yaml
시나리오: 사용자에게 할당된 Role을 삭제할 때 영향도 확인
사전조건:
  - 여러 사용자에게 해당 Role이 할당됨
기대결과:
  검증항목:
    - Role 삭제 성공
    - 해당 사용자들의 Role 할당 해제됨
    - 관련 Permission 접근 불가
```

### TC-ROLE-011: 존재하지 않는 Role 삭제 [P1]
```yaml
시나리오: 존재하지 않는 roleId로 삭제 시도
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
```

---

# 6. 정책 검증 테스트 시나리오

## 6.1 개인정보/위치정보 플래그 자동 업데이트

### TC-POL-001: 리소스 매핑 시 개인정보 플래그 상향 전파 [P0]
```yaml
시나리오: 개인정보 리소스 매핑 시 상위 메뉴까지 플래그가 전파되는지 확인
구조:
  - GROUP (id=1)
    - ITEM (id=2) <- personalInfo 리소스 매핑
테스트_단계:
  1. ITEM(id=2)에 personalInfoHandleYn=true 리소스 매핑
  2. 메뉴 상세 조회
기대결과:
  검증항목:
    - ITEM(id=2) privacyIncludeYn=true
    - GROUP(id=1) privacyIncludeYn=true
```

### TC-POL-002: 리소스 제거 시 플래그 재계산 [P0]
```yaml
시나리오: 개인정보 리소스 제거 시 플래그가 재계산되는지 확인
사전조건:
  - GROUP(id=1) > ITEM(id=2) 구조
  - ITEM(id=2)에 개인정보 리소스만 매핑됨
  - 둘 다 privacyIncludeYn=true
테스트_단계:
  1. ITEM(id=2)의 리소스 매핑 제거
  2. 메뉴 상세 조회
기대결과:
  검증항목:
    - ITEM(id=2) privacyIncludeYn=false
    - GROUP(id=1) privacyIncludeYn=false (다른 하위 메뉴 없는 경우)
```

### TC-POL-003: 형제 메뉴의 플래그 독립성 [P1]
```yaml
시나리오: 형제 메뉴의 플래그가 서로 독립적인지 확인
구조:
  - GROUP (id=1)
    - ITEM (id=2) <- personalInfo 리소스
    - ITEM (id=3) <- 일반 리소스
기대결과:
  검증항목:
    - ITEM(id=2) privacyIncludeYn=true
    - ITEM(id=3) privacyIncludeYn=false
    - GROUP(id=1) privacyIncludeYn=true (하위 중 하나라도 true면 true)
```

### TC-POL-004: 리소스 수정 시 메뉴 플래그 재계산 [P0]
```yaml
시나리오: Resource의 personalInfoHandleYn 변경 시 연결된 메뉴 플래그 재계산
테스트_단계:
  1. 일반 리소스가 메뉴에 매핑됨 (privacyIncludeYn=false)
  2. 해당 리소스의 personalInfoHandleYn을 true로 수정
  3. 메뉴 상세 조회
기대결과:
  검증항목:
    - 메뉴의 privacyIncludeYn=true로 자동 변경
    - 상위 메뉴도 재계산됨
```

---

## 6.2 캐시 정책 검증

### TC-POL-005: 캐시 TTL 검증 [P1]
```yaml
시나리오: 캐시 TTL(8시간)이 정상 작동하는지 확인
테스트_단계:
  1. 첫 번째 권한 메뉴 조회 (캐시 미스)
  2. 동일 조건으로 재조회 (캐시 히트)
  3. 응답 시간 비교
기대결과:
  검증항목:
    - 두 번째 조회가 현저히 빠름 (캐시 히트)
    - 캐시 TTL 8시간 확인
```

### TC-POL-006: 데이터 변경 시 캐시 무효화 [P0]
```yaml
시나리오: Role/Menu/Resource 변경 시 캐시가 즉시 무효화되는지 확인
테스트_단계:
  1. 권한 메뉴 조회 (캐시 생성)
  2. 메뉴 수정
  3. 즉시 권한 메뉴 재조회
기대결과:
  검증항목:
    - 변경된 내용이 즉시 반영됨
    - 이전 캐시 데이터가 반환되지 않음
```

### TC-POL-007: Role 변경 시 캐시 무효화 범위 [P1]
```yaml
시나리오: Role 변경 시 해당 Client-ID 관련 모든 캐시가 무효화되는지 확인
테스트_단계:
  1. 여러 사용자가 같은 클라이언트 권한 메뉴 조회
  2. 해당 클라이언트의 Role 수정
  3. 모든 사용자의 권한 메뉴 재조회
기대결과:
  검증항목:
    - 모든 사용자에게 변경 사항 반영됨
    - 다른 클라이언트 캐시는 유지됨
```

---

## 6.3 권한 변경 반영 검증

### TC-POL-008: 전자결재 승인 후 권한 반영 [P0]
```yaml
시나리오: 전자결재 승인 완료 후 사용자 권한이 반영되는지 확인
사전조건:
  - 사용자가 특정 권한 그룹 미소속
테스트_단계:
  1. 전자결재로 권한 그룹 신청
  2. 승인 완료
  3. Keycloak Group 매핑 확인
  4. 권한 메뉴 조회
기대결과:
  검증항목:
    - Keycloak에 Group 매핑 반영됨
    - 새로운 권한에 해당하는 메뉴 노출됨
```

### TC-POL-009: 권한 변경 최대 반영 시간 [P1]
```yaml
시나리오: 권한 변경 후 최대 5분 이내 반영되는지 확인
테스트_단계:
  1. 관리자가 사용자 권한 직접 변경
  2. 5분 간격으로 권한 메뉴 조회
기대결과:
  검증항목:
    - 최대 5분 이내 변경 반영 (RPT 캐시 TTL)
    - 캐시 무효화 시 즉시 반영
```

---

# 7. 에러 처리 테스트 시나리오

## 7.1 400 Bad Request

### TC-ERR-001: Validation 실패 - 필수 필드 누락 [P1]
```yaml
시나리오: 필수 필드가 누락된 요청 처리
테스트_케이스:
  - 클라이언트 생성 시 clientId 누락
  - 메뉴 생성 시 name 누락
  - Resource 생성 시 uris 누락
기대결과:
  status_code: 400
  error:
    code: 400
    status: "BAD_REQUEST"
    message: "Validation 실패" 또는 구체적 메시지
    details: array
```

### TC-ERR-002: Validation 실패 - 형식 오류 [P1]
```yaml
시나리오: 형식이 올바르지 않은 데이터 처리
테스트_케이스:
  - UUID 형식이 아닌 resourceId
  - 숫자가 아닌 menuId
  - 유효하지 않은 enum 값 (type, scope 등)
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
```

### TC-ERR-003: 선행 조건 실패 [P1]
```yaml
시나리오: 선행 조건이 충족되지 않은 요청 처리
테스트_케이스:
  - 하위 메뉴 존재 시 상위 메뉴 삭제 (cascade=false)
  - Keycloak 미등록 클라이언트에서 Role 생성
기대결과:
  status_code: 400
  error:
    status: "BAD_REQUEST"
    details: 구체적인 실패 이유
```

---

## 7.2 403 Forbidden

### TC-ERR-004: 권한 없는 사용자 접근 [P0]
```yaml
시나리오: 권한 없는 사용자가 관리 API에 접근
테스트_케이스:
  - 일반 사용자가 메뉴 생성 시도
  - 타 클라이언트 메뉴 수정 시도
  - Resource 삭제 권한 없는 사용자의 삭제 시도
기대결과:
  status_code: 403
  error:
    code: 403
    status: "FORBIDDEN"
    message: "해당 작업을 수행할 권한이 없습니다." 또는 구체적 메시지
```

### TC-ERR-005: 타 사용자 리소스 접근 [P0]
```yaml
시나리오: 다른 사용자/클라이언트의 리소스에 접근 시도
테스트_케이스:
  - 다른 클라이언트의 메뉴 수정
  - 권한 없는 Resource 접근
기대결과:
  status_code: 403
  error:
    status: "FORBIDDEN"
```

---

## 7.3 404 Not Found

### TC-ERR-006: 존재하지 않는 리소스 [P1]
```yaml
시나리오: 존재하지 않는 ID로 리소스 접근
테스트_케이스:
  - 존재하지 않는 clientId
  - 존재하지 않는 menuId
  - 존재하지 않는 resourceId
  - 존재하지 않는 roleId
기대결과:
  status_code: 404
  error:
    code: 404
    status: "NOT_FOUND"
    message: "{리소스}를 찾을 수 없습니다."
```

### TC-ERR-007: 삭제된 리소스 접근 [P2]
```yaml
시나리오: 이미 삭제된 리소스에 접근
테스트_단계:
  1. 리소스 삭제
  2. 동일 ID로 조회/수정/삭제 시도
기대결과:
  status_code: 404
  error:
    status: "NOT_FOUND"
```

---

## 7.4 401 Unauthorized

### TC-ERR-008: 인증 토큰 없음 [P0]
```yaml
시나리오: Authorization 헤더 없이 API 호출
테스트_케이스:
  - /api/v2/clients/authorized
  - /api/v2/menus/authorized
기대결과:
  status_code: 401
  error:
    status: "UNAUTHORIZED"
```

### TC-ERR-009: 만료된 토큰 [P0]
```yaml
시나리오: 만료된 JWT 토큰으로 API 호출
기대결과:
  status_code: 401
  error:
    status: "UNAUTHORIZED"
    message: "토큰이 만료되었습니다."
```

### TC-ERR-010: 유효하지 않은 토큰 형식 [P1]
```yaml
시나리오: 잘못된 형식의 토큰으로 API 호출
테스트_케이스:
  - "Bearer " 없이 토큰만
  - 유효하지 않은 JWT 문자열
  - 다른 시스템의 토큰
기대결과:
  status_code: 401
  error:
    status: "UNAUTHORIZED"
```

---

## 7.5 500 Internal Server Error

### TC-ERR-011: Keycloak 연동 실패 [P1]
```yaml
시나리오: Keycloak 서버 장애 시 에러 처리
사전조건:
  - Keycloak 서버 다운 또는 연결 불가
테스트_케이스:
  - Role 생성 시 Keycloak 연동 실패
  - Resource 등록 시 Keycloak 연동 실패
기대결과:
  status_code: 500
  error:
    status: "INTERNAL_SERVER_ERROR"
    message: "Keycloak 연동 중 오류가 발생했습니다."
```

### TC-ERR-012: DB 연결 실패 [P1]
```yaml
시나리오: 데이터베이스 연결 실패 시 에러 처리
기대결과:
  status_code: 500
  error:
    status: "INTERNAL_SERVER_ERROR"
```

---

## 7.6 504 Gateway Timeout

### TC-ERR-013: 요청 처리 타임아웃 [P2]
```yaml
시나리오: 대량 데이터 처리 시 타임아웃 발생
테스트_케이스:
  - 대량 Resource 일괄 생성
  - 복잡한 권한 계산
기대결과:
  status_code: 504
  error:
    status: "GATEWAY_TIMEOUT"
```

---

# 8. 보안 테스트 시나리오

## 8.1 인증/인가

### TC-SEC-001: 세션 고정 공격 [P0]
```yaml
시나리오: 로그인 전후 세션 ID 변경 확인
테스트_단계:
  1. 로그인 전 세션/토큰 확인
  2. 로그인 수행
  3. 새로운 토큰 발급 확인
기대결과:
  검증항목:
    - 로그인 후 새 JWT 토큰 발급됨
    - 이전 토큰 무효화됨
```

### TC-SEC-002: 브루트포스 공격 방어 [P1]
```yaml
시나리오: 반복적인 잘못된 인증 시도 시 계정 잠금
테스트_단계:
  1. 잘못된 자격증명으로 N회 로그인 시도
  2. 계정 잠금 또는 지연 확인
기대결과:
  검증항목:
    - N회 실패 후 일정 시간 계정 잠금
    - 또는 지연 시간 증가
```

### TC-SEC-003: 권한 우회 시도 [P0]
```yaml
시나리오: URL 직접 접근으로 권한 우회 시도
테스트_케이스:
  - 권한 없는 클라이언트 메뉴 직접 조회
  - 다른 사용자의 Resource 직접 접근
기대결과:
  검증항목:
    - 모든 경우 403 또는 404 응답
    - 권한 우회 불가
```

---

## 8.2 Injection 공격

### TC-SEC-004: SQL Injection - 메뉴명 [P0]
```yaml
시나리오: 메뉴명에 SQL Injection 공격 코드 삽입
테스트_데이터:
  - "'; DROP TABLE menus;--"
  - "' OR '1'='1"
  - "1; SELECT * FROM users"
기대결과:
  검증항목:
    - SQL 명령이 실행되지 않음
    - 적절한 이스케이프 처리
    - 데이터베이스 무결성 유지
```

### TC-SEC-005: XSS 공격 - Stored XSS [P0]
```yaml
시나리오: 메뉴/클라이언트 설명에 XSS 코드 저장 시도
테스트_데이터:
  - "<script>alert('XSS')</script>"
  - "<img src=x onerror=alert('XSS')>"
  - "javascript:alert('XSS')"
기대결과:
  검증항목:
    - 스크립트가 실행되지 않음
    - HTML 태그 이스케이프 또는 제거
    - 안전하게 렌더링됨
```

### TC-SEC-006: XSS 공격 - URL 파라미터 [P1]
```yaml
시나리오: URL 쿼리 파라미터에 XSS 코드 삽입
테스트_데이터:
  - keycloakClientId=<script>alert(1)</script>
  - format="><script>alert(1)</script>
기대결과:
  검증항목:
    - 스크립트 실행 안 됨
    - 적절한 에러 응답 또는 이스케이프
```

---

## 8.3 접근 제어

### TC-SEC-007: 수평적 권한 상승 [P0]
```yaml
시나리오: 동일 권한 레벨의 다른 사용자 데이터 접근 시도
테스트_단계:
  1. 사용자 A로 로그인
  2. 사용자 B의 리소스 ID로 직접 접근
기대결과:
  검증항목:
    - 다른 사용자 데이터 접근 불가
    - 403 또는 404 응답
```

### TC-SEC-008: 수직적 권한 상승 [P0]
```yaml
시나리오: 낮은 권한 사용자가 높은 권한 기능 접근 시도
테스트_케이스:
  - 일반 사용자가 관리자 전용 API 호출
  - 조회 권한만 있는 사용자가 수정/삭제 시도
기대결과:
  검증항목:
    - 권한 상승 불가
    - 403 Forbidden 응답
```

### TC-SEC-009: IDOR (Insecure Direct Object Reference) [P0]
```yaml
시나리오: 예측 가능한 ID로 다른 객체 접근 시도
테스트_단계:
  1. menuId=10 조회 성공
  2. menuId=11 (다른 클라이언트 메뉴) 조회 시도
기대결과:
  검증항목:
    - 권한 없는 객체 접근 불가
    - 적절한 에러 응답
```

---

## 8.4 데이터 보호

### TC-SEC-010: 개인정보 노출 검증 [P0]
```yaml
시나리오: API 응답에 민감한 정보가 노출되지 않는지 확인
검증항목:
  - 에러 메시지에 스택 트레이스 미포함
  - 시스템 내부 정보 미노출
  - 다른 사용자 개인정보 미노출
```

### TC-SEC-011: 로그 내 민감정보 [P1]
```yaml
시나리오: 로그에 민감한 정보가 기록되지 않는지 확인
검증항목:
  - JWT 토큰 전체가 로그에 미기록
  - 사용자 비밀번호 미기록
  - 개인정보 마스킹 처리
```

---

# 9. 성능 테스트 시나리오

### TC-PERF-001: 대량 메뉴 조회 성능 [P2]
```yaml
시나리오: 100개 이상의 메뉴가 있는 클라이언트 조회 성능
기대결과:
  응답시간: < 500ms
  검증항목:
    - 트리 구조 생성 성능
    - 권한 필터링 성능
```

### TC-PERF-002: 동시 사용자 처리 [P2]
```yaml
시나리오: 100명의 동시 사용자가 권한 메뉴 조회
기대결과:
  평균_응답시간: < 1s
  에러율: < 1%
```

### TC-PERF-003: Resource 일괄 생성 성능 [P3]
```yaml
시나리오: 100개 이상의 Resource 일괄 생성
기대결과:
  응답시간: < 30s
  검증항목:
    - 트랜잭션 무결성
    - 부분 실패 처리
```

---

# 10. 회귀 테스트 시나리오

### TC-REG-001: 기존 어드민 시스템 호환성 [P0]
```yaml
시나리오: 기존 어드민 서비스의 API 권한이 정상 작동하는지 확인
검증항목:
  - 기존 등록된 API들의 권한 처리 현행 유지
  - 인증/인가 로직 충돌 없음
  - 기존 사용자 권한 유지
```

### TC-REG-002: Keycloak 마이그레이션 후 권한 [P0]
```yaml
시나리오: RBAC에서 UMA 2.0으로 마이그레이션 후 권한 정상 작동
검증항목:
  - 기존 Role 마이그레이션 완료
  - Group-Role 매핑 유지
  - Group-User 매핑 유지
```

---

# 부록: 테스트 데이터 명세

## A. 테스트 계정

| 역할 | 설명 | 권한 범위 |
|------|------|----------|
| 백오피스포탈 관리자 | 전체 시스템 관리 권한 | 모든 클라이언트 CRUD |
| 백오피스포탈 제품 운영자 | 특정 제품 메뉴 관리 | 담당 클라이언트 메뉴 CRUD |
| 백오피스포탈 제품 사용자 | 메뉴 조회 및 기능 사용 | 권한 있는 메뉴 조회만 |

## B. 테스트 클라이언트

| keycloakClientId | 설명 | 용도 |
|------------------|------|------|
| phoenix-test1 | 피닉스 테스트 | 메뉴 관리 테스트 |
| partner-center | 파트너센터 | 권한 분리 테스트 |
| backoffice-admin | 백오피스 어드민 | Resource/Role 테스트 |

## C. 응답 시간 기준

| API 유형 | 목표 응답시간 |
|----------|--------------|
| 단순 조회 | < 200ms |
| 복합 조회 (권한 포함) | < 500ms |
| 생성/수정 | < 1s |
| 일괄 처리 | < 30s |

---

# 변경 이력

| 버전 | 날짜 | 변경 내용 | 작성자 |
|------|------|----------|--------|
| 1.0 | 2026-01-08 | 초기 작성 | QA Scenario Writer |
